<#@ template language="C#v3.5" #>
// <autogenerated>
// This code was generated by a tool. Any changes made manually will be lost
// the next time this code is regenerated.
// </autogenerated>

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace PingLang.Core.Lexing
{
    public static class Tokens
    {
<#= tokenConstants() #>

		public static readonly Dictionary<int, string> TokenNames = new Dictionary<int, string>
        {
<#= tokenNamePairs() #>        
        };
                
        public static readonly List<TokenRecognizer> All = new List<TokenRecognizer>
        {
<#= tokenRecognizers() #>
        };
    }
}
<#+	

	// **********************************************************************
	// The IMPORTANT STUFF is here - the list of tokens
	// used by this template to generate the Tokens class.
	// **********************************************************************

	TokenInfo[] tokens = new TokenInfo[]{
		new TokenInfo { token = "EOF" }, 
		new TokenInfo { token = "WS",         regex = "^([ \\t])+", dont_include = true }, 
		new TokenInfo { token = "T" ,         regex = "^[\r\n;]+"}, 		
		new TokenInfo { token = "ACTOR_END" , regex = "^\\."}, 
		new TokenInfo { token = "LISTEN" ,    regex = "^listen on port"},
		new TokenInfo { token = "WHEN" ,      regex = "^when"},
		new TokenInfo { token = "MESSAGE" ,   regex = "^message"}, 
		new TokenInfo { token = "PRINT" ,     regex = "^print"},
		new TokenInfo { token = "PINGED" ,    regex = "^pinged"}, 
		new TokenInfo { token = "STARTING" ,  regex = "^starting"},		
		new TokenInfo { token = "PING" ,      regex = "^ping"},
		new TokenInfo { token = "WAIT" ,      regex = "^wait"},
		new TokenInfo { token = "SEND" ,      regex = "^send"},
		new TokenInfo { token = "TO_PORT" ,   regex = "^to port"}, 
		new TokenInfo { token = "ERROR" ,     regex = "^error"},
		new TokenInfo { token = "COUNT" ,     regex = "^count every"},
		new TokenInfo { token = "RESET" ,     regex = "^reset counter"},
		new TokenInfo { token = "COUNTER" ,   regex = "^counter"}, 
		new TokenInfo { token = "END" ,       regex = "^end"},		
		new TokenInfo { token = "GT" ,        regex = "^\\>"},		
		new TokenInfo { token = "ID" ,        regex = "^([a-zA-Z])+([\\w\\-])*"},		
		new TokenInfo { token = "COMMENT" ,   regex = "^[(\\/\\/)#][^\\r\\n]*", dont_include = true }, 		
		new TokenInfo { token = "INT" ,       regex = "^(\\d)+"},
		new TokenInfo { token = "STRING" ,    regex = "^\"[^\\r\\n\"]*\""},
		new TokenInfo { token = "PROGRAM" }
	};

	class TokenInfo 
	{
		public string token {get;set;}
		public string regex {get;set;}
		public bool dont_include {get;set;}	 
	}
		
	string tokenConstants()
	{
		int i = -1;
		string buffer = string.Empty;
		foreach(var t in tokens)
		{
			buffer += "\t\tpublic const int " + t.token + " = " + i + ";\r\n";
			i++;
		}
		return buffer;
	}
	
	string tokenNamePairs()
	{
		string buffer = "";
		foreach(var t in tokens)
		{
			buffer += "\t\t\t{" + t.token + ", \"" + t.token + "\"},\r\n";
		}
		return buffer;
	}
	
	string tokenRecognizers()
	{
		string buffer = "";
		foreach(var t in tokens)
		{
			if(string.IsNullOrEmpty(t.regex)) continue;
			buffer += string.Format("\t\t\tnew TokenRecognizer({0}, \"{1}\", {2}),\r\n",
				t.token,
				t.regex.Replace("\r", "\\r").Replace("\n", "\\n").Replace("\\", "\\\\").Replace("\"", "\\\""),
				t.dont_include ? "false" : "true");
		}
		return buffer;
	}
#>